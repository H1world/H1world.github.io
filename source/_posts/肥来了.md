---
title: react常见问题汇总。
date: 2018-11-27 16:55:38
categories: 随笔
tags: [react,前端]
---
  每天记录一点点.
<!--more-->
### mobx使用
因为最先接触的是reactNative，所以就跟之前一样 使用mobx来作为数据管理工具。需要注意的是mobx5需要浏览器支持`proxy`才可以使用，对于不支持`proxy`的浏览器是无法获取mobx状态的。[mobx官网](https://cn.mobx.js.org/)
安装`npm install mobx --save`，React 绑定库: `npm install mobx-react --save`,
package.json:
```json
"mobx": "^4.3.1",
"mobx-react": "^5.0.0",
```
具体使用时可以分开管理使用，栗子：
```
Mobx
│   AppState.js
│   devState.js    
│   getAndSet.js    
│
index.js（入口文件）
```
```jsx
// devState
import { observable } from "mobx";
class DevStore {
  @observable devApi = 'http://dev.com'
}
const devStore = new DevStore();
export default devStore;
---
// AppState
import devStore from "./devState";
let apiStore = { };
if (process.env.REACT_APP_SECRET_API === "dev"){ //环境变量
  apiStore = devStore;
}
const store = { apiStore };
export default store;
---
// index.js
import React from 'react';
import ReactDOM from 'react-dom';
import { Provider } from 'mobx-react';
import AppState from './Mobx/AppState';
import AppRouter from './router/routers';
import registerServiceWorker from './registerServiceWorker';
ReactDOM.render(
  <Provider {...AppState}>
      <AppRouter />
  </Provider>,
  document.getElementById('root'));
registerServiceWorker();
```
```js
import { observable } from "mobx";
class DevStore {
  @observable demoString = '嘻嘻'
}
const devStore = new DevStore();
export default devStore
```
###读取、写入状态
栗子：
```jsx
//getAndSet
import { action, computed, observable } from "mobx";
class HomeStore {
  @observable num = 0;
  @action
  setNum(info) {
    this.num = info
  }
  @computed
  get getNum() {
    return this.num
  }
}
const homeStore = new HomeStore(); 
export default homeStore;
---
//组件内运用 demo.js
import { inject, observer } from "mobx-react";
@inject('HomeStore')
@observer
class Demo extends Component {
  addNum = () =>{
    this.props.HomeStore.num++;
  };
  reduceNum = () => {
    this.props.HomeStore.num--;
  };
  render{
    return(
      <div>
        <div className="demo">
            {this.state.beforNum}
            <br/>
            {this.props.HomeStore.num}
        </div>
        <button onClick={this.addNum} type="button">
          增加
        </button>
        <button onClick={this.reduceNum} type="button">
          减少
        </button>
      </div>
    )
  }
}
```
>这只是简单的应用，具体参考mobx官网文档。
### router v4这个坑货。
reactRouterV4版本，[REACTROUTERV4官网](https://reacttraining.com/react-router/web/guides/quick-start)。核心思想为：万物为组件，组件就是路由。所以习惯于路由单独管理的我，面对V4版本是极其难受的，刚开始思想就是转不过来。不过慢慢就喜欢了。此篇记录的是代码中需要注意的事项，还请仔细阅读官方文档。以官网为主
#### 主要使用
`npm install react-router react-router-dom --save;`
项目中新建router文件夹处理路由，在文件夹内新建build.js和router.js;
build.js可以把它看为一个中转站，路由守卫。和vue里的beforEach类似，只是react并未提供此类方法，故自己封装一下
```jsx
import React from 'react'
export default class Bundle extends React.Component {
  state = {
    // short for "module" but that's a keyword in js, so "mod"
    mod: null,
  };
  componentWillMount() {
    this.load(this.props)
    this.setTitle(this.props.title);
  }
  componentWillReceiveProps(nextProps) {
    if (nextProps.load !== this.props.load) {
      this.load(nextProps)
      this.setTitle(nextProps.title);
    }
  }
  //设置标题
  setTitle(title) {
    document.title = title || '设置标题';
  }
  load(props) {
    this.setState({
      mod: null
    });
    props.load((mod) => {
      this.setState({
        // handle both es imports and cjs
        mod: mod.default ? mod.default : mod
      })
    })
  }
  render() {
    // return this.props.children(this.state.mod)
    return this.state.mod ? this.props.children(this.state.mod) : null;
  }
}
```
router.js用来创建路由实例 后面会说到拆分路由。其中bundle-loader用来配合异步加载组件，我使用的是creat-react-app脚手架，看代码。
```jsx
import * as React from 'react';
import { Switch, Route, HashRouter, BrowserRouter } from 'react-router-dom';
import Bundle from './bundle';
//引入页面
import App from 'bundle-loader?lazy&name=app!../App';
import Page from 'bundle-loader?lazy&name=page!../page';
//创建build方法，用于处理路由状况。
const Loading = () => <div>Loading...</div>;
const lazyLoad = (loadComponent, title) => (props) => {
  return(
    <Bundle load={loadComponent} title={title}>
      {Comp => (Comp ? <Comp {...props} /> : <Loading />)}
    </Bundle>
  )
};
class AppRouter extends React.Component {
//router v4将路由钩子函数都pass掉了 改用正常的react生命周期来处理.
  componentWillMount() { };
  componentWillUpdate() { };
  componentWillUnmount() { };
  render() {
    return (
      <div>
        <BrowserRouter>
          <Switch>
            <Route exact={true} path={"/"} component={lazyLoad(App)} />
            <Route path={"/Login"} component={lazyLoad(Page)} />  
          </Switch>
        </BrowserRouter>  
      </div>
    )
  }
}
export default AppRouter; 
```
```jsx
// 入口Index.js 结合mbox
import React from 'react';
import ReactDOM from 'react-dom';
import { Provider } from 'mobx-react';
import AppState from './Mobx/AppState';
import AppRouter from './router/routers';
import registerServiceWorker from './registerServiceWorker';
ReactDOM.render(
  <Provider {...AppState}>
      <AppRouter />
  </Provider>,
  document.getElementById('root'));
registerServiceWorker();
```
#### 拆分路由
为了不让路由过于杂乱，配合react-router-config做到路由拆分：
在某个page版块新建route.js，单独配置此版块的路由。
```jsx
//page
import * as React from 'react';
import Bundle from '../../router/bundle';
import About from 'bundle-loader?lazy&name=about!./about';
import NoaMatch from 'bundle-loader?lazy&name=404!../../page/404';
const lazyLoad = (loadComponent, title) => (props) => {
  return (
    <Bundle load={loadComponent} title={title}>
      {Comp => (Comp ? <Comp {...props} /> : " ")}
    </Bundle>
  )
};
const PageRouter = [
  {
    path: "/About",
    component: lazyLoad(About, '关于')
  },
  {
    path: "/404",
    component: lazyLoad(NoaMatch)
  },
  {
    component: lazyLoad(NoaMatch)
  },
]
export default PageRouter
//主router
import { renderRoutes } from 'react-router-config'; 
import PageRouter from "../page/router";  //将版块引入
//********************结合上面主路由配置
<Switch>
  {renderRoutes(PageRouter)}
</Switch>
```
>待续